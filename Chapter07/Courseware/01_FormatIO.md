---
marp: true
theme: MyGaia
paginate: true
---
<!-- _class: lead -->
# **格式化输入输出**

---

### **格式化I/O**

+ 为了控制输入输出的格式，C++的I/O流允许对I/O操作进行格式化，例如，可以设置域宽度、指定数字基数以及决定显示小数点后面的数字位数。
+ 有*两种*相互关联但概念上不同的格式化数据的方式。
+ 第一种方式是直接访问`ios`类的成员，确切地说，可以设置`ios`类内定义的各种格式状态标志或调用各种`ios`成员函数；
+ 第二种方式是使用称为操纵算子（manipulator）的特殊函数，该函数是I/O表达式的一部分。

---

### **流格式状态标志和格式化函数**

每一个流都与一组格式状态标志相关联，这组标志可以控制输入输出流的格式。这些标志通过逻辑运算符“|”或起来可以形成一个掩码，定义成`fmtflags`枚举类型（有些编译器是`long`型）。流格式状态标志及其含义见下表：

---

| 标志               | 说明                                                                               |
| ------------------ | ---------------------------------------------------------------------------------- |
| `ios::skipws`      | 跳过输入流中的空白字符                                                             |
| `ios::left`        | 在域中左对齐输出，必要时在右边显示填充字符                                         |
| `ios::right`       | 在域中右对齐输出，必要时在左边显示填充字符                                         |
| `ios::internal`    | 表示数字的符号应在域中左对齐，而数字值应在域中右对齐（即在符号和数值之间填充字符） |
| `ios::adjustfield` | `left`，`right`和`internal`可以通称为对齐域                                        |
| `ios::dec`         | 指定整数作为十进制(基数10)值                                                       |
| `ios::oct`         | 指定整数作为八进制(基数8)值                                                        |

---

| 标志             | 说明                                                                             |
| ---------------- | -------------------------------------------------------------------------------- |
| `ios::hex`       | 指定整数作为十六进制(基数16)值                                                   |
| `ios::basefield` | `oct`，`dec`和`hex`通称为基数域                                                  |
| `ios::showbase`  | 指定在数值前面输出进制（0表示八进制，0x或0X表示十六进制）                        |
| `ios::showpoint` | 指定浮点数输出时应带小数点。通常和`ios::fixed`一起使用，保证小数点后面有一定位数 |
| `ios::uppercase` | 指定表示十六进制的x应为大写，表示浮点数科学计数法的e应为大写                     |

---

| 标志              | 说明                                                 |
| ----------------- | ---------------------------------------------------- |
| `ios::showpos`    | 指定正数和负数前面分别加上+和-号                     |
| `ios::scientific` | 指定浮点数输出采用科学记数法                         |
| `ios::fixed`      | 指定浮点数输出采用定点符号，保证小数点后面有一定位数 |
| `ios::floatfield` | `scientific`和`fixed`域可以称为浮点域                |
| `ios::boolalpha`  | 指定可以用关键字`true`和`false`输入或输出布尔值      |
| `ios::unitbuf`    | 指定缓冲区在每次插入操作之后都会被刷新               |

---

### **设置标志**

1. **`setf()/unsetf()`**：为了设置一个标志，可以使用`setf()`函数。这个函数是一个`ios`成员，其最常用的形式如下所示：
```cpp
fmtflags setf(fmtflags flags);
```
这个函数开启由`flags`指定的那些标志，并返回先前设置的格式标志。例如，为了开启`showpos`标志，可以使用下面的语句：
```cpp
stream.setf(ios::showpos);
```

---

### **设置标志**

这里，`stream`是希望影响的流。由于`showpos`是`ios`类定义的枚举常量，所以使用时必须用`ios`域加以限定。

+ `setf()`是`ios`类的成员函数并且对该类创建的流产生影响，理解这一概念非常重要。对`setf()`的所有调用都与一个特定的流相关，`setf()`不能被自己调用，即在C++中没有全局格式状态的概念，每一个流都单独维护自己的格式状态信息。

+ 对于一次要设置多个标志值，可以简单地利用`|`（按位或）运算符把想要设置的标志值放在一起，而不是多次调用`setf()`。

---
  
### **设置标志**
例如，下面仅通过一个调用就可以实现显示正数和负数前面分别加上+和-号，以及浮点数输出采用科学记数法：
```cpp
cout.setf(ios::scientific | ios::showpos);
```

---

### **清除标志**

`unsetf()`与`setf()`互补，这个`ios`成员函数用于清除一个或多个格式标志。该函数的一般形式如下所示：

```cpp
void unsetf(fmtflags flags);
```
`flags`指定的标志将被清除（所有其他标志则不受影响）。

---

### **例子**
下面的程序说明了`unsetf()`的用法。该程序先是设置了`uppercase`和`scientific`标志，然后用科学计数法输出100.12，此时，科学计数法使用的是大写的“E”。接下来，该程序清除了`uppercase`标志并再次以科学记数法用小写的“e”输出100.12。
```cpp
int main() {
    cout.setf(ios::uppercase | ios::scientific);
    cout<<100.12;
    cout.unsetf(ios::uppercase);
    cout << "\n" << 100.12;
    return 0;
}
```

---

### **使用flags**

**`flags()`**：成员函数`flags()`返回流格式标志的当前设置。其原型如下所示：
```cpp
fmtflags flags();
```
`flags()`函数还有一种形式，它可以设置与某个流相关的所有格式标志。这种`flags()`版本的原型如下所示：
```cpp
fmtflags flags(fmtflags f);
```
当使用这种版本时，`f`中的位模式用于设置与流相关的格式标志，因而所有格式标志都将受到影响。该函数返回先前的设置。

---

### **其它成员函数**
 **`width()/precision()/fill()`**：除格式化标志之外，`ios`还定义了三个成员函数`width()`，`precision()`和`fill()`，这些函数可以分别设置域宽、精度和填充字符。

默认情况下，当输出一个值时，它所占据的空间只是显示时占据的字符个数。然而，可以利用`width()`函数指定一个最小域宽。该函数的原型如下所示：
```cpp
streamsize width(streamsize w);
```
---

### **width函数**
这里，`w`是将要设定的域宽，先前的域宽被返回。在具体实现中，域宽必须在每个*输出之前*被设置，否则将采用默认域宽。`streamsize`被编译器定义为某种整型形式。

设置了最小域宽之后，当某个值小于指定的宽度时，则域将用当前的填充字符（默认情况下为空格）填充以达到指定的域宽。如果某个值超出了最小域宽，域将会超出限度，此时不会截去该值。

---

### **precision函数**
当输出浮点值时，可以使用`precision()`函数确定数字的精度位数。该函数的原型如下所示：
```cpp
streamsize precision(streamsize p);
```
这里，精度设置为`p`，先前的值将被返回。精度的默认值为6。在具体实现中，精度必须在输出每个浮点值*之前设置*，否则将采用默认精度。

---

### **fill函数**
默认情况下，当需要填充一个域时将使用空格填充。也可以利用`fill()`函数指定填充字符。该函数的原型如下所示：
```cpp
char fill(char ch);
```
在调用`fill()`后，`ch`将变成新的填充字符，先前的填充字符被返回。

---

### **例子**
```cpp
int main() {
    cout.precision(4);
    cout.width(10);
    cout << 10.12345 << "\n";
    cout.fill('*');
    cout.width(10);
    cout << 10.12345 << "\n";
    cout.width(10);
    cout << "Hi!" << "\n"; 
    cout.width(10);
    cout.setf(ios::left);
    cout << 10.12345;
    return 0;
}
```

---

### **结果**

程序的输出如下：
```
     10.12
*****10.12
*******Hi!
10.12*****
```
---

### **流操纵符**
进行格式化输入输出的另一种方法是使用称为流操纵符（manipulator）的一些特殊函数，这些函数可以包含在I/O表达式中。标准C++流操纵符见下表：

---

| 流操纵符    | 用途                   | 输入／输出 |
| ----------- | ---------------------- | ---------- |
| `boolalpha` | 开启`boolapha`标志     | 输入／输出 |
| `dec`       | 开启`dec`标志          | 输入／输出 |
| `endl`      | 输出一个换行符并刷新流 | 输出       |
| `ends`      | 输出一个null           | 输出       |
| `fixed`     | 开启`fixed`标志        | 输出       |
| `flush`     | 刷新一个流             | 输出       |
| `hex`       | 开启`hex`标志          | 输入／输出 |
| `internal`  | 开启`internal`标志     | 输出       |

---

| 流操纵符      | 用途                | 输入／输出 |
| ------------- | ------------------- | ---------- |
| `Left`        | 开启`left`标志      | 输出       |
| `nobooalpha`  | 关闭`boolalpha`标志 | 输入／输出 |
| `Noshowbase`  | 关闭`showbase`标志  | 输出       |
| `Noshowpoint` | 关闭`showpoint`标志 | 输出       |
| `Noshowpos`   | 关闭`showpos`标志   | 输出       |
| `Noskipws`    | 关闭`skipws`标志    | 输入       |
| `nounitbuf`   | 关闭`unitbuf`标志   | 输出       |
| `nouppercase` | 关闭`uppercase`标志 | 输出       |

---

| 流操纵符                    | 用途                 | 输入／输出 |
| --------------------------- | -------------------- | ---------- |
| `oct`                       | 开启`oct`标志        | 输入／输出 |
| `resetiosflags(fmtflags f)` | 关闭`f`中指定的标志  | 输入／输出 |
| `right`                     | 开启`right`标志      | 输出       |
| `scientific`                | 开启`scientific`标志 | 输出       |
| `setbase(int base)`         | 将基数设置为`base`   | 输入／输出 |
| `setfill(int ch)`           | 将填充字符设置为`ch` | 输出       |
| `setiosflags(fmtflags f)`   | 开启`f`中指定的标志  | 输入／输出 |
| `setprecision(int p)`       | 设置数字精度         | 输出       |

---

| 流操纵符      | 用途                | 输入／输出 |
| ------------- | ------------------- | ---------- |
| `setw(int w)` | 将域宽设置为`w`     | 输出       |
| `showbase`    | 开启`showbase`标志  | 输出       |
| `showpoint`   | 开启`showpoint`标志 | 输出       |
| `showpos`     | 开启`showpos`标志   | 输出       |
| `skipws`      | 开启`skipws`标志    | 输入       |
| `unitbuf`     | 开启`unitbuf`标志   | 输出       |
| `uppercase`   | 开启`uppercase`标志 | 输出       |
| `ws`          | 跳过开始的空格      | 输入       |

---

### **使用**
为了访问带参数的流操纵符，必须在程序中包含头文件`<iomanip>`。

C++流操纵符提供了许多功能，如设置域宽、设置精度、设置和清除格式化标志、设置域填充字符、刷新流、在输出流中插入换行符并刷新该流、在输出流中插人空字符、跳过输入流中的空白字符等等。

---

### **例子**
```cpp
int main() {
    int n;
    cout << "Enter a decimal number: ";
    cin >> n;
    cout << n << " in hexadecimal is: " 
         << hex << n << '\n'
         << dec << n << " in octal is: " 
         << oct << n << '\n'
         << setbase(10) << n << " in decimal is: " 
         << n << endl;
    return 0;
}
```

---

### **结果**
输入输出：
```
Enter a decimal number:  20
20 in hexadecimal is:  14
20 in octal is:  24
20 in decimal is:  20
```

---

### **分析**
整数通常被认为是十进制（基数为10）整数。插入流操纵符`hex`可设置十六进制基数（基数为16），插入流操纵符`oct`可设置八进制基数（基数为8），插入流操纵符`dec`可恢复十进制基数。也可以用流操纵符`setbase`来改变基数，流操纵符`setbase`带有一个整数参数10、8或16。因为流操纵符`setbase`是带有参数的，所以也称之为参数化的流操纵符。使用`setbase`或其他任何参数化的操纵算子都必须在程序中包含头文件`iomanip`。如果不明确地改变流的基数，流的基数是不变的。
