---
marp: true
theme: gaia
paginate: true
---
<style>
   em{
        font-style: normal;
        font-weight: bold;
        color: purple;
   }
</style>

<!-- _class: lead -->
# **派生类**

---

### **派生类的声明**

派生类声明的一般格式为：
```cpp
class 派生类名：继承方式 基类名1，继承方式 基类名2，…，继承方式 基类名n
{
    新增加的成员声明；
};
```
+ 其中，基类必须是已有的类的名称，派生类名则是新建的类名。继承方式有三种，即公有继承（`public`），私有继承（`private`）和保护继承（`protected`）。
+ 如果不显式地给出继承方式关键字，系统的默认值就是私有继承（`private`）。

---

### **派生类的声明**

+ 不同继承方式下，派生类自身及其对象对基类成员访问控制权限不同。
+ 一个派生类可以只有一个基类，这种情形称为*单继承*，前一讲的`Dog`类就是单继承的例子；也可以同时有多个基类，这种情形称为*多继承*。

---

### **多继承的例子**

+ 这个例子是有关航天飞机的。我们知道，飞机有机翼、起落架等部件，可以多次起飞和降落，但无法进入太空；火箭则因为安装了火箭发动机，可以垂直发射进入太空旅行，但无法着陆，只能一次性使用。
+ 而航天飞机同时拥有飞机和火箭的特性，能像火箭那样垂直发射进入太空，像飞机那样水平着陆，在地球和太空间多次穿梭旅行。可以认为航天飞机是从飞机和火箭多重继承而来。类声明如下：

---

### **多继承的例子**

```cpp
//飞机类 
class Plane
{
    char Wing; //机翼
    char Undercarriage; //起落架
public:
    void Land();//着陆方法
};
//火箭类
class Rocket
{
    char RocketEngine;//火箭发动机
public:
    void Launch();//发射方法
};
```

---

### **多继承的例子**
```cpp
//航天飞机类 
class SpaceShuttle : public Plane, public Rocket{};
```
这是多继承的情形。航天飞机类拥有机翼、起落架和火箭发动机三个属性，同时有着陆和发射两个成员函数。

---

### **派生类**

+ 一个基类可以派生出多个派生类，如从`Animal`类中还可以派生出教师类`Cat`：
+ 派生类一经声明，就继承了基类*除构造函数和析构函数以外*的所有成员，实现了代码重用，这些从基类继承的成员也体现了派生类从基类继承而获得的共性。
+ 派生类在继承基类成员的基础上，一般都会有所变化，主要体现在两个方面：一方面是*增加新的成员*，另一方面是对基类的某些成员进行*改造或调整*，这些变化体现了派生类和基类的不同，体现了不同派生类之间的区别。

---

### **派生类**

对于派生类的构造而言，并不是把基类的成员和增加的成员简单地加在一起，而是包含三部分的工作：
1. **从基类接收成员**：派生类继承了基类除构造函数和析构函数以外的所有成员，是没有选择的，不能选择接收基类的一部分成员而舍弃另一部分成员。

---

### **派生类**

2. **派生类对基类的扩充**：增加新的成员是派生类对基类的扩充，体现了派生类功能的扩展。派生类`Dog`增加了成员函数`bark()`，`Cat`类增加了成员函数`Jump`，是扩充了基类。派生类`SpaceShuttle`虽然没有直接增加新的成员，但它将`Plane`类和`Rocket`类的成员集中在一起，也是对基类扩充的一种方式。

---

### **派生类**

3. **派生类对基类成员的改造**：派生类不能对接收基类的成员进行选择，但是可以对这些成员进行某些调整。一方面，派生类通过继承方式，可以改变对基类成员的访问权限；另一方面派生类可以对基类成员函数进行*重定义*。如果派生类定义了一个与*基类函数名称相同*，而*参数表不同*的成员函数，则称派生类*重载*了基类成员函数。这时与普通的函数重载的情况一样，系统会根据函数参数的不同而调用不同函数版本，如果派生类定义的成员函数名称和参数表与基类的成员函数完全一致，则称派生类覆盖了基类同名成员函数，这样新成员就取代了基类的成员函数。（如果基类的函数为虚函数，则称为重写）

---

### **派生类的继承方式和访问属性**

1. 在类的内部，根据类的作用域规则，基类的成员函数可以访问基类的成员，不能访问派生类的成员；派生类的成员函数可以访问派生类自己增加的成员。
2. 在类的外部，根据对象访问的原则，派生类对象可以访问派生类自己增加的公有成员，不能访问派生类的私有成员，基类对象也只能访问自己的公有成员。
3. 派生类的成员函数访问基类的成员，以及派生类的对象访问基类的成员，不仅要考虑到基类成员所声明的访问属性，还要考虑派生类声明时对基类的继承方式，由这两个因素共同决定基类成员在派生类中的访问属性。

----

### **公有继承**
在声明派生类时，将基类的继承方式指定为`public`称为公有继承。
1. 基类公有成员相当于派生类的公有成员，即派生类可以像访问自身公有成员一样，访问从基类继承的公有成员。
2. 基类保护成员相当于派生类的保护成员，即派生类可以像访问自身的保护成员一样，访问基类的保护成员。
3. 对于基类的私有成员，派生类内部成员无法直接访问，在派生类外部也无法通过派生类对象直接访问。
简单地说，对于公有继承，基类的公有成员和保护成员在派生类中保持原有的属性，而基类的私有成员仍然为基类私有，不能被派生类的成员函数或派生类对象访问，成为派生类中不可访问的成员。

---

### **私有继承**
在声明派生类时，将基类的继承方式指定为`private`称为私有继承。
1. 基类公有成员和保护成员在派生类中的访问属性都相当于派生类的私有成员，派生类可以通过自身的成员函数访问它们。
2. 基类的私有成员仍然为基类私有，无论派生类成员函数或派生类对象都无法直接访问，是派生类中不可访问的成员。

派生类可以继续派生子类。如果派生类本身是通过私有继承产生的，则基类的公有及保护成员都已成为当前派生类的私有成员。所以，当由派生类继续派生子类时，基类的公有及保护成员就会成为新子类难于访问的成员，也就失去了派生类的意义。正因为此，私有继承一般不常使用。

---

### **保护继承**
由`protected`声明的成员称为“保护成员”。保护成员不能在类外被类的对象访问，这点和私有成员类似，保护成员对类的用户而言是私有的。但是，保护成员可以被派生类的成员函数引用，这一点与私有成员不同，在前面有关公有继承和私有继承的叙述中也有所说明。

基类中的私有成员是任何派生类都不能访问的，而保护成员一方面像私有成员一样不能被类外的对象访问，另一方面又能被派生类的成员函数访问。因此，一旦类中声明了保护成员，就意味着该类可能要作为基类，派生类中要访问这些成员。

---

### **保护继承**

在声明派生类时，将基类的继承方式指定为`protected`称为保护继承。
1. 基类的公有成员和保护成员都相当于派生类的保护成员，派生类可以通过自身的成员函数访问它们。
2. 基类的私有成员仍然为基类私有，无论派生类成员函数或派生类对象都无法直接访问，是派生类中不可访问的成员。

从以上叙述可知，在保护继承中，基类的公有成员和保护成员可以被派生类的成员函数访问，在类外不能直接访问，在这一层次上，保护继承和私有继承没有差别。
 