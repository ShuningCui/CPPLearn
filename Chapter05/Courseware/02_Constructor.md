---
marp: true
theme: gaia
paginate: true
---
<style>
   em{
        font-style: normal;
        font-weight: bold;
        color: purple;
   }
</style>

<!-- _class: lead -->
# **派生类的构造函数**

---

### **构造函数**

+ 基类的构造函数和析构函数不能被继承，在派生类中，如果对派生类新增的成员进行初始化，就必须加入新的构造函数。
+ 对所有从基类继承下来的成员的初始化工作，还是*应由基类的构造函数*完成，因此必须在派生类中对基类的构造函数所需要的参数进行设置。
+ 派生类的构造函数承担着初始化派生类对象的任务。它不仅要初始化派生类自身的成员变量，还得处理基类成员的初始化。

---

### **基本语法**

    派生类名::派生类名(参数总表):基类名1(参数表1),…，基类名n(参数表n),
           内嵌对象名1(对象参数表1),…,内嵌对象名m(对象参数表m),
           成员变量(1),...,成员变量(m)
    {	派生类初始化代码；}

---

### **说明**
+ 当派生类属于多继承形式时，声明中才会出现多个基类名，若是单继承，则只有一个基类名出现;
+ 若基类使用缺省构造函数或不带参数的构造函数，则在派生类声明中可略去“基类名(参数表)”；若此时派生类及内嵌对象都不需初始化，则可以不定义派生类构造函数，即使用缺省构造函数；
+ 参数总表包含了*全部基类和全部内嵌对象的所有参数*，同时也应包含*派生类新增成员初始化的参数*；

---

### **说明**

+ 派生类构造函数名后面括号内的参数总表包括参数的类型和参数名，而基类构造函数名和内嵌对象名后面括号内的参数表*只有参数名而不包括参数类型*。这里不是定义基类的构造函数，而是*调用基类的构造函数*，这些参数是*实参*而不是形参。
+ 有两种情况必须定义派生类构造函数：一种是派生类本身需要，另一种是基类的构造函数带有参数。

---

### **调用基类构造函数**
当创建派生类对象时，会先调用基类的构造函数，之后再调用派生类自身的构造函数。
- **默认调用**：若派生类构造函数未显式调用基类构造函数，那么会调用基类的默认构造函数（即无参构造函数）。
- **显式调用**：若基类没有默认构造函数，或者你想调用基类的带参构造函数，就需要在派生类构造函数的初始化列表中显式调用基类构造函数。

---

### **初始化顺序**
在创建派生类对象时，构造函数的调用顺序如下：
1. 调用基类的构造函数。
2. 调用内嵌对象的构造函数。
3. 按照成员变量在类中声明的顺序，依次调用成员变量的构造函数。
4. 执行派生类构造函数的函数体。

---

### **析构函数的调用顺序**
+ 析构函数的功能是在类对象消亡之前释放占用资源（如内存）的工作。由于析构函数无参数、无类型，因而派生类的析构函数相对简单的多。
+ 派生类与基类的析构函数没有什么联系，彼此独立，派生类或基类的析构函数只作各自类对象消亡前的善后工作，因而在派生类中有无显式定义的析构函数与基类无关。

---

### **析构顺序**
派生类析构函数执行过程恰与构造函数执行过程相反：
1. 执行派生类析构函数的函数体。
2. 按照成员变量在类中声明的逆序，依次调用成员变量的析构函数。
3. 调用内嵌对象的析构函数。
4. 调用基类的析构函数。
