---
marp: true
theme: MyGaia
paginate: true
---
<!-- _class: lead -->
# **多态概述**

---

### **基本概念**

+ 多态性（polymorphism）的英文单词polymorphism源于希腊词根poly（意为“很多”）和morph（意为“形态”），顾名思义，是指一个事物有多种形态。在现实生活中，有许多多态性的例子。例如，当上课的铃声响起时，同学们坐到了座位上，而老师则站上了讲台；对于不同班级的同学，也会走进不同的教室。这里，对于“上课的铃声”这个相同的消息，*不同的对象作出了不同的响应，即使他们都是“人”类的对象*。

---

### **基本概念**

+ 在C++中，多态性的含义也是如此，即指某类的对象在接受同样的消息时，所做出的响应不同。这里“接受同样的消息”指*调用名称相同的成员函数*，“所做出的响应不同”指*函数实现的功能不同*。
+ 多态性是面向对象程序设计的重要特征。在C++中，多态性有两种不同的形式：编译时多态性和运行时多态性。

---

### **编译时多态**

+ 编译时多态性指*同一类*的*不同对象*或是同一个对象在不同环境下，调用名称相同的成员函数，所完成功能不同。
+ 函数（包括类成员函数）的重载和运算符的重载都属于这一类。这种确定操作具体对象的过程就是绑定（binding），也就是把一个标识符和一个存储地址联系在一起的过程；
+ 用面向对象的术语讲，就是把一条消息和一个对象的方法相结合的过程。这种在编译连接阶段完成绑定工作的情况称为静态绑定。

---

### **运行时多态**

+ 运行时多态性是指*同属于某一基类的不同派生类对象*，在形式上调用*自基类继承的同一成员函数*时，实际调用了各自*派生类的同名函数成员*。运行时多态性是通过使用*继承和虚函数*实现的，在程序运行阶段完成绑定工作，称为动态绑定，又称晚期绑定或后绑定。
+ 动态绑定使绑定可以从一个调用改变为另一个调用。因此，如果一个类层次在调用之间发生变化，这个变化将被反映在最终的绑定中。结果，动态绑定无需重新编译程序就能够实现。动态绑定的主要不足是运行时的时间开销稍大于静态绑定。但尽管如此，动态绑定几乎在所有的面向对象的语言和系统中都给予了实现，动态绑定提供的灵活性是一个面向对象的环境所期望的关键特征之一。
  
---

### **例子**

第一个例子是关于兔子的。将兔子抽象化为一个类后，可以具有许多成员函数。其中“逃生”成员函数，表达了兔子逃命的不同方法。当遇到老鹰袭击时，兔子会使用“兔子蹬鹰”的绝招。当遇到狼的攻击时，兔子则采用“动如脱兔”的逃跑方法。
```cpp
class  兔子
{
public:
void  逃生（老鹰a）{“兔子蹬鹰”；}
void  逃生（狼  b）{“动如脱兔”；}
……
}；
```
---

### **例子**

+ 显而易见，这就是函数重载。在使用这些函数时，它们的参数都是在编码时设定好的。也就是说，当调用“兔子”类的“逃生”函数时，传入的参数是“老鹰”或是“狼”的对象，是在编译时就确定了，不会改变。因而在代码编译时使用哪一个版本的函数，也可以确定。这种多态性就是编译时的多态性。

---

### **例子**

一个小孩得知邻居家养了几个宠物，但不知是猫是狗。于是，小孩丢一块石头到邻居家院中，以探明真相。这里，宠物作为基类，拥有一个speak()函数，即发声函数。而猫类和狗类是宠物类的派生类，并各有一个基类speak()函数的同名覆盖。示意代码如下：

```cpp
class  宠物
{
public:
    void speak() { cout<< "zzz"; };
    …
};
```
---

### **例子**

```cpp
class  猫 : public 宠物
{public:
    void speak() { cout<< "miao!miao!"; }
    …
};
class  狗 : public宠物
{public:
    void speak() { cout<< "wang!wang!"; }
        …
};
```

---

### **例子**

小孩丢石块，相当于调用了宠物类对象的speak()函数。因为小孩并不知是猫是狗，只知道是宠物。然而实际接受此消息的却是宠物的派生类对象，如果是猫则发出“miao! miao!”字符串；如果是狗，则发出“wang! wang!”字符串。
```cpp
void main()
{	宠物 *p；       //p为宠物类指针
	猫	  cat1;		//定义猫类对象 
	狗	  dog1;		//定义狗类对象
根据用户输入将猫或狗对象地址赋给p指针，
例如用户输入1，则执行p = &cat1; 用户输入2，则执行p = &dog1;
    p->speak()； 	
……
}
```

---

### **说明**
+ 由于小孩只知道对象是宠物类，所以main()函数定义了宠物类指针p。按照我们的设想：指针p应根据实际情况指向猫类或狗类对象；最后，语句p->speak()调用的应该是p所指向派生类的speak()函数。
+ 按照这种设想，程序在编译阶段并不知道指针p将指向什么对象，所以在编译阶段就无法确定p将调用哪个类的speak()函数。只有在运行阶段才能确定p的值，从而动态决定调用哪一个类的speak()成员函数。这正是运行时多态性的典型形式。
+ 然而，上面的程序段并*不会*按照我们的设想运行。实际上，上面的程序段执行时，不论指针p所指对象是宠物类还是其派生类，p->speak()只能调用基类—宠物类的speak()方法。

---

### **派生类替换基类对象**

+ 公有派生类全盘继承了基类的成员及其访问权限。因此公有派生类对象*可以替代基类*对象做本来由基类对象所做的事情。凡是基类对象出现的场合都可以用公有派生类对象替换。
+ 对象替换常见的形式有：
  + 派生类对象给基类对象赋值
  + 派生类对象可以初始化基类对象的引用
  + 可以令基类对象的指针指向派生类对象，即将派生类对象的地址传递给基类指针

---

### **例子**

```cpp 
class Pet 						//基类
{public:
	void Speak() { cout<<"How does a pet speak ?"<<endl; } 
};
class Cat : public Pet 			//派生类
{public:
	void Speak() { cout<<"miao!miao!"<<endl; }
}; 
class Dog : public Pet			//派生类
{public:
	void Speak() { cout<<"wang!wang!"<<endl; }
};
```

---

### **例子**

```cpp
int main()
{
	Pet	obj,*p1;		//基类对象指针p1, 基类对象obj
	Dog dog1;
	Cat cat1; 
	obj = dog1;		//用Dog类对象给Pet类对象赋值
	obj.Speak();	
	p1 = &cat1; 		//用Cat类对象地址给基类指针赋值
	p1->Speak(); 
	p1 = &dog1; 		//用Dog类对象地址给基类指针赋值
	p1->Speak(); 
	Pet& p4 = cat1;	//以Cat类对象初始化Pet类引用 
	p4 .Speak();
	return 0;
}
```

---

### **例子**

#### 输出
How does a pet speak ?
How does a pet speak ?
How does a pet speak ?
How does a pet speak ?

---

### **分析**
+ 主函数依次调用Speak函数。派生类对象cat1给基类对象obj赋值，而后通过obj调用Speak函数，得到第一行输出。
+ 令基类类型指针p1分别指向派生类对象cat1和dog1，而后通过p1调用Speak函数，得到第二和第三行输出。
+ 派生类对象cat1初始化基类引用p4后，通过p4调用Speak函数，得到最后一行输出。
+ 显而易见，三种方式调用的*都是基类Speak函数*。因而可以得到下面论断：不论那一种情形，*派生类对象替代基类对象后，只能当作基类对象来使用*。不论派生类是否存在同名覆盖成员，这样的基类对象所访问的成员都只能来自基类。
