---
marp: true
theme: MyGaia
paginate: true
---
<!-- _class: lead -->
# **抽象类**

---

### **抽象类**
+ 类是从相似对象抽取共性而得到的抽象数据类型。当把类看作一种数据类型时，通常认定该类型的对象是要被实例化的。但是，在许多情况下，定义不实例化为任何对象的类是很有用处的，这种类称为*抽象类(abstract class)。*
+ 因为抽象类要作为基类被其他类继承，所以通常也把它称为“抽象基类”(abstract base class)。抽象类*不能用来建立实例化的对象。*

---

### **抽象类**

+ 这些抽象类表述的含义因为太广泛而定义不出实在的对象，如果要建立实例对象，则需要含义更加明确的类，这就是所谓的*具体类（concrete class）。*
+ 抽象类的*惟一用途是为其他类提供合适的基类*，其他类可从它这里继承和(或)实现接口。能够建立实例化对象的类称为具体类。具体类具有足以能够建立实例化对象的明确含义。
+ 类的抽象化程度越高，离现实中的具体对象就越远，同时也就能概括更大范围事物的共同特性。有时侯，从软件使用者的角度看，某个软件只需要用到一些具体事物的类，例如*猫类、狗类*等；但从软件设计者的角度看，增加一个更加抽象的基类效果更好如*宠物类*。

----

### **抽象类**

+ 通过设置基类，实现了代码重用。同时，当基类的抽象化程度提高之后，某些成员函数在基类中的实现变得没有意义了，但成员函数在基类中的声明仍有意义。如Speak函数的声明实现了多态性，但Speak在宠物类里的具体实现*并无实际意义*。
+ 因为无人知道抽象的宠物会如何发声。有没有办法将这样的成员函数在基类中只作声明，而将其实现留给派生类呢？在C++中，这样的办法是有的。就是利用*纯虚函数*将基类改造为抽象类。

----

### **纯虚函数**

纯虚函数是没有在基类中定义的虚函数。纯虚函数的语法定义为：
    
    virtual  返回类型  函数名（参数表）=0

+ 容易看出，纯虚函数与虚函数的不同，就是在虚函数的*最后加上“=0”。* 
+ 纯虚函数在基类声明后，*不能*定义其函数体。纯虚函数的具体实现只能在派生类中完成。纯虚函数是为了实现多态性而存在的。
+ 当一个虚函数变为纯虚函数时，任何派生类必须给出自己的定义，覆盖该纯虚函数，否则将导致编译错误。

---

### **抽象类**

+ 至少包含一个纯虚函数的类称为抽象类。抽象类为其所有子类提供了统一的操作界面。使其派生类具有一系列统一的方法。关于抽象类的使用有几点要求：
  + 抽象类不能实例化，即不能声明抽象类对象。如果Pet为抽象类，则语句Pet p1是错误的。
  + 抽象类只作为基类被继承，无派生类的抽象类毫无意义。
  + 可以定义指向抽象类的指针或引用，这个指针或引用必然指向派生类对象。从而实现多态性。
