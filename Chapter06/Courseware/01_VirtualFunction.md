---
marp: true
theme: gaia
paginate: true
---
<style>
   em{
        font-style: normal;
        font-weight: bold;
        color: purple;
   }
</style>

<!-- _class: lead -->
# **虚函数和抽象类**

---

### **虚函数**

+ 可以用基类对象指针指向派生类对象，但只能访问基类的成员。为了实现多态性，也就是能够通过指向派生类的基类指针，访问派生类中同名覆盖成员函数，需要将基类的同名函数声明为*虚函数*。
+ 虚函数是一个成员函数，该成员函数在基类内部声明并且被派生类重新定义。为了创建虚函数，应在基类中该函数声明的前面加上关键字virtual。当继承包含虚函数的类时，派生类将重新定义该虚函数以符合自身的需要。
+ 从本质上讲，虚函数实现了“一个接口，多种方法”的理念，而这种理念是多态性的基础。基类内部的虚函数定义了该函数的接口形式，而在派生类中对虚函数重新定义，创建一个具体的方法。

---

### **虚函数**
+ “正常”访问时，虚函数就像所有其他类型的类成员函数一样。然而，虚函数之所以能够支持运行时的多态性，就在于当基类指针指向包含虚函数的派生对象时，C++会根据该指针所指的对象类型决定调用的虚函数版本。
+ 这一决定是在运行时做出的，因此，当指针指向不同的对象时，就执行该虚函数的不同版本。*这同样适用于基类引用*。

---

### **虚函数的语法**

    virtual  函数返回类型  函数名（参数表）{函数体}

也就是说，只需要简单地在基类同名函数前加上virtual关键字，就可以将函数设置为虚函数。

---

### **例子**

```cpp
class Pet 	//基类
{
public:
	virtual void Speak() { cout<<"How does a pet speak ?"<<endl; } 
};
class Cat : public Pet 	//派生类	
{
public:
	virtual void Speak() { cout<<"miao!miao!"<<endl; }
}; 
class Dog : public Pet	//派生类
{
public:
	virtual void Speak() { cout<<"wang!wang!"<<endl; }
};
```

---

### **例子**

```cpp
int main()
{
	Pet	obj,*p1; //基类对象指针p1, 基类对象obj
	Dog dog1;
	Cat cat1; 
	obj = dog1;	//用Dog类对象给Pet类对象赋值
	obj.Speak();	
	p1 = &cat1; //用Cat类对象地址给基类指针赋值
	p1->Speak(); 
	p1 = &dog1; //用Dog类对象地址给基类指针赋值
	p1->Speak(); 
	Pet	&p4 = cat1;	//以Cat类对象初始化Pet类引用 
	p4 .Speak();
	return 0;
}
```

---

### **输出**

How does a pet speak ?
miao!miao!
wang!wang!
miao!miao!

---

### **分析**

+ 主函数分别调用Speak()函数，因为obj为基类的对象，所以输出基类的Speak()，得到第一行输出；指针p1指向派生类，通过它们调用Speak()函数，这时系统需要选择，是调用基类的Speak()函数，还是调用派生类的Speak()函数？
+ 在本程序中Speak()函数的声明中加了关键字“virtual”，而p1又是指向派生类的指针，因此调用派生类的Speak()函数，得到第二、三行的输出；p4是对Cat对象的引用，得到第四行输出。

---

### **注意**
+ 应通过*指针或引用*调用虚函数，而*不要*以对象名调用虚函数
+ 从替换原则出发，派生类对象可以赋值给基类对象。但是赋值给基类对象之后，函数虽然仍可以顺利执行，所调用的函数却*是基类的函数*。
+ 在C++中*一定要用指针或引用*来调用虚函数，才能保证多态性的成立。
+ 引用有其自身的特点，即引用一旦初始化后，就无法重新赋值。所以采用引用实现方式显然不够灵活，最好的方式是使用指针调用。

---

### **注意**

+ 在派生类中重定义的基类虚函数仍为虚函数，同时可以省略virtual关键字。虚函数重定义时，函数的名称，返回类型，参数类型，个数及顺序与基类虚函数*完全一致*。
+ 在c++11后，可以使用*override*关键字，显式的表示虚函数的重写。
+ 乍看上去，利用派生类对虚函数进行的重新定义类似于函数重载，然而实际上却并非如此。重新定义的虚函数原型必须完全符合基类中指定的原型，而重载一个函数时，不是参数个数不同，就是参数类型不同，二者之中必须有至少有一个不同!

---

### **注意**

+ C++正是通过这些差异才能够选出正确的重载函数版本。+ 如果在重新定义虚函数时改变了它的原型，那么该函数只能被认为是由C++编译器重载的，其虚函数特性也将丧失。
+ 不能定义虚构造函数，可以定义虚析构函数。
+ 多态性是指对象对同一消息的不同反应。在对象产生之前或消亡之后，多态性都没有意义。而构造函数只在对象产生之前调用一次，所以虚构造函数没有意义。而析构函数的作用是在对象消亡之前进行的资源回收等收尾工作。因而定义虚析构函数是有意义的，虚析构函数可以利用多态性，保证基类类型指针能调用适当的析构函数对不同的对象进行善后工作。
