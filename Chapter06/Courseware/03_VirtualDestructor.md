---
marp: true
theme: gaia
paginate: true
---
<style>
   em{
        font-style: normal;
        font-weight: bold;
        color: purple;
   }
</style>

<!-- _class: lead -->
# **虚析构函数**

---

### **虚析构函数的概念**

+ 在 C++ 里，析构函数是在对象生命周期结束时被调用的特殊成员函数，其作用是释放对象占用的资源。当使用基类指针指向派生类对象时，若基类的析构函数并非虚函数，那么在通过基类指针删除派生类对象时，*只会调用基类*的析构函数，而*不会调用派生类*的析构函数，这就可能造成资源泄漏。
+ 虚析构函数的引入正是为了解决这个问题。当基类的析构函数被声明为虚函数后，在通过基类指针删除派生类对象时，会先调用派生类的析构函数，再调用基类的析构函数，以此保证所有资源都能被正确释放。

---

### **例子**
下面给出一个使用虚析构函数的实际例子：

```cpp
// 基类
class Base {
public:
    Base() {
        std::cout << "Base 构造函数被调用" << std::endl;
    }
    // 声明为虚析构函数
    virtual ~Base() {
        std::cout << "Base 析构函数被调用" << std::endl;
    }
};
```

---

### **例子**

```cpp
// 派生类
class Derived : public Base {
private:
    int* data;
public:
    Derived() {
        data = new int[10];
        std::cout << "Derived 构造函数被调用" << std::endl;
    }
    ~Derived() {
        delete[] data;
        std::cout << "Derived 析构函数被调用" << std::endl;
    }
};
```

---

### **例子**

```cpp
int main() {
    Base* basePtr = new Derived();
    delete basePtr;
    return 0;
}
```
### **代码解释**
1. **基类 `Base`**：构造函数输出相应信息，同时将析构函数声明为虚析构函数。
2. **派生类 `Derived`**：构造函数中为 `data` 指针分配了内存，析构函数里释放该内存并输出相应信息。

---

### **代码解释**
3. **`main` 函数**：创建一个指向 `Derived` 对象的 `Base` 指针 `basePtr`，然后通过 `delete` 操作符删除 `basePtr`。因为 `Base` 的析构函数是虚析构函数，所以在删除 `basePtr` 时，会先调用 `Derived` 的析构函数，进而释放 `data` 指针所指向的内存，之后再调用 `Base` 的析构函数。

若 `Base` 的析构函数不是虚析构函数，那么在删除 `basePtr` 时，只会调用 `Base` 的析构函数，`Derived` 的析构函数不会被调用，这就会造成 `data` 指针所指向的内存无法释放，最终导致资源泄漏。

---

### **虚析构函数和普通析构函数的区别**

#### 声明方式
- **普通析构函数**：普通析构函数是类的一个成员函数，其名称与类名相同，前面加上波浪号 `~`，不使用 `virtual` 关键字修饰。
- **虚析构函数**：虚析构函数在普通析构函数的基础上，使用 `virtual` 关键字进行修饰。示例如下：

---

#### 多态性
- **普通析构函数**：不具备多态性。当使用基类指针指向派生类对象，通过该基类指针删除对象时，只会调用基类的析构函数，而不会调用派生类的析构函数。这可能会导致派生类中动态分配的资源无法被正确释放，造成资源泄漏。
- **虚析构函数**：具有多态性。当基类的析构函数被声明为虚析构函数时，通过基类指针删除派生类对象时，会先调用派生类的析构函数，再调用基类的析构函数，确保所有资源都能被正确释放。
