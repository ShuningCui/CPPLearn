---
marp: true
theme: gaia
paginate: true
---
<style>
   em{
        font-style: normal;
        font-weight: bold;
        color: purple;
   }
</style>

<!-- _class: lead -->
# **运算符重载**

---

### **基本概念**
在C++里，运算符重载是一项强大的特性，它能让你为自定义的数据类型重新定义运算符的行为。借助运算符重载，你可以让自定义类型的对象像内置类型那样使用运算符，这样能让代码更易读和编写。

运算符重载本质上是一种特殊的函数重载。你能够针对自定义类定义运算符函数，从而让这些运算符可以操作该类的对象。运算符函数的命名格式为 `operator` 加上要重载的运算符，例如 `operator+` 就是重载加法运算符。

---

### **语法**
运算符重载函数既可以是*类的成员函数*，也可以是*全局函数*。下面是基本的语法结构：

#### 成员函数形式
```cpp
class ClassName {
public:
    // 返回类型 operator运算符(参数列表) {
    //     函数体
    // }
    ClassName operator+(const ClassName& other) {
        // 实现加法逻辑
    }
};
```

---

#### 全局函数形式
```cpp
class ClassName {
    // 类的定义
};

// 返回类型 operator运算符(参数列表) {
//     函数体
// }
ClassName operator+(const ClassName& obj1, const ClassName& obj2) {
    // 实现加法逻辑
}
```

---

### **可重载与不可重载的运算符**
1. **可重载的运算符**：大多数常见的运算符都能被重载，例如算术运算符（`+`、`-`、`*`、`/`、`%`）、关系运算符（`==`、`!=`、`<`、`>`、`<=`、`>=`）、逻辑运算符（`&&`、`||`、`!`）、位运算符（`&`、`|`、`^`、`~`、`<<`、`>>`）、赋值运算符（`=`、`+=`、`-=`、`*=`、`/=` 等）、自增自减运算符（`++`、`--`）、函数调用运算符（`()`）、下标运算符（`[]`）、指针解引用运算符（`*`、`->`）等。
2. **不可重载的运算符**：有一些运算符不能被重载，如成员访问运算符（`.`）、作用域解析运算符（`::`）、条件运算符（`?:`）、`sizeof` 运算符、`typed` 运算符。

---

### **运算符重载的语法规则**
1. **函数命名**：运算符重载函数的命名格式是 `operator` 加上要重载的运算符，例如 `operator+` 表示重载加法运算符。
2. **返回类型**：运算符重载函数的返回类型要根据运算符的语义来确定。例如，重载加法运算符通常返回一个新的对象，而重载赋值运算符通常返回 `*this` 的引用。
3. **参数列表**：参数列表要根据运算符的操作数个数和类型来确定。对于成员函数形式的运算符重载，第一个操作数是隐含的 `this` 指针所指向的对象；对于全局函数形式的运算符重载，需要为每个操作数都提供显式参数。

---

### **运算符的优先级和结合性**
重载运算符不会改变运算符原有的优先级和结合性。例如，在重载了 `+` 和 `*` 运算符后，`*` 运算符的优先级仍然高于 `+` 运算符。

### **保持运算符的原有语义**
重载运算符时，应该尽量保持运算符的原有语义，让其行为与内置类型的运算符行为相似，避免让代码的阅读者产生困惑。例如，重载加法运算符时，应该实现对象之间的加法逻辑，而不是实现减法逻辑。

---

### 特殊运算符的重载规则
1. **赋值运算符（`=`）**：赋值运算符只能作为类的成员函数进行重载。如果没有为类显式定义赋值运算符，编译器会自动生成一个默认的赋值运算符。
2. **自增自减运算符（`++`、`--`）**：自增自减运算符有前置和后置两种形式。为了区分这两种形式，后置形式的运算符重载函数需要额外增加一个 `int` 类型的参数（这个参数只是一个占位符，在函数体中通常不会被使用）。
3. **函数调用运算符（`()`）**：函数调用运算符可以让对象像函数一样被调用，这种对象被称为函数对象或仿函数。函数调用运算符可以有任意数量和类型的参数。

---

### **运算符重载函数中访问类的私有成员**

+ 使用成员函数形式的运算符重载
当运算符重载函数作为类的成员函数时，它可以直接访问类的私有成员，因为成员函数本身就拥有对类的私有成员的访问权限。
+ 使用*友元函数*形式的运算符重载
当运算符重载函数作为全局函数时，它不能直接访问类的私有成员。此时，可以将该全局函数声明为类的友元函数，这样它就可以访问类的私有成员了。
