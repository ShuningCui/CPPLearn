---
marp: true
theme: gaia
paginate: true
---

<!-- _class: lead -->
# 动态内存分配

---

### **基本概念**
+ 在C++里，动态内存分配允许程序在运行时分配和释放内存，这在处理大小不确定的数据时非常关键。
+ 在程序运行期间，有时候无法提前知道所需内存的大小。例如，当程序需要存储用户输入的任意数量的数据时，动态内存分配就可以根据实际需求来分配合适大小的内存。

---

### **使用`new`和`delete`操作符**
- **`new`操作符**：用于在堆上分配内存。它会返回一个指向所分配内存的指针。
```cpp
// 分配单个对象的内存
int* ptr = new int;
*ptr = 10;

// 分配数组的内存
int* arr = new int[5];
for (int i = 0; i < 5; ++i) {
    arr[i] = i;
}
```
---

### **使用`new`和`delete`操作符**
- **`delete`操作符**：用于释放`new`分配的单个对象的内存。
```cpp
delete ptr;
```
- **`delete[]`操作符**：用于释放`new[]`分配的数组的内存。
```cpp
delete[] arr;
```

---


### **动态内存分配的风险**
- **内存泄漏**：如果使用`new`分配了内存，但没有使用`delete`或`delete[]`释放，就会导致内存泄漏。随着程序的运行，泄漏的内存会越来越多，最终可能导致系统资源耗尽。
- **悬空指针**：当使用`delete`或`delete[]`释放内存后，如果仍然保留指向该内存的指针，这个指针就会变成悬空指针。访问悬空指针会导致未定义行为。

---

### **智能指针**
为了避免手动管理内存带来的风险，C++提供了智能指针。智能指针会自动管理所指向的内存，当智能指针超出作用域时，会自动释放其所指向的内存。
- **`std::unique_ptr`**：独占所指向的对象，同一时间只能有一个指针指向该对象。
- **`std::shared_ptr`**：可以共享所指向的对象，使用引用计数来管理内存。当引用计数为0时，会自动释放内存。

---

### **例子**
```cpp
#include <memory>
std::unique_ptr<int> uniquePtr = std::make_unique<int>(20);
```

```cpp
std::shared_ptr<int> sharedPtr1 = std::make_shared<int>(30);
std::shared_ptr<int> sharedPtr2 = sharedPtr1;
```
 