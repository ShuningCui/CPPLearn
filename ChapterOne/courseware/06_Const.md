---
marp: true
theme: gaia
paginate: true
---

<!-- _class: lead -->
# **const** 修饰符

---

### **修饰常量变量**
在C++里，`const` 修饰符能够让你指定一个对象或者变量是常量，这意味着一旦初始化之后，其值就不能再被修改。<br><br>

```cpp
const int num = 10;
// num = 20;  // 错误：不能给常量赋值
int const num2 = 20;
//也可以把const放在类型声明后面
```

---

### **修饰指针**
`const` 可以修饰指针本身，也可以修饰指针所指向的内容，或者两者都修饰。

**指向常量的指针**
```cpp
int a = 10;
const int* ptr = &a;
// *ptr = 20;  // 错误：不能通过指针修改所指向的常量
a = 20;  // 可以直接修改a的值
```

---

**常量指针**
```cpp
int b = 10;
int* const ptr2 = &b;
*ptr2 = 20;  // 可以通过指针修改所指向的值
// ptr2 = &a;  // 错误：不能修改指针本身的值
```

**指向常量的常量指针**

```cpp
int c = 10;
const int* const ptr3 = &c;
// *ptr3 = 20;  // 错误：不能通过指针修改所指向的值
// ptr3 = &a;  // 错误：不能修改指针本身的值
```

---

### **修饰函数参数**

当函数参数使用 `const` 修饰时，能够保证函数内部不会修改传入参数的值。

```cpp
void printValue(const int value) {
    // value = 20;  // 错误：不能修改常量参数
    std::cout << value << std::endl;
}
```
通过使用 `const` 修饰符，可以增强程序的安全性和可读性，减少因意外修改而产生的错误。

---

### **`const` 和 `#define`**
- `const`是有类型的常量。编译器会对其进行类型检查。
- `#define` 定义的常量是无类型的宏替换。不会进行类型检查。
- `const` 常量有明确的作用域。仅在定义它的作用域内有效。
- `#define` 定义的常量没有作用域的概念。
- `const` 常量定义更直观，便于理解和维护。
- `#define` 定义的常量,会降低代码的可读性和可维护性。

在C++中推荐优先使用 `const` 常量，因为它能提供更好的类型安全、作用域控制和可维护性。