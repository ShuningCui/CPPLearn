---
marp: true
theme: MyGaia
paginate: true
---
<!-- _class: lead -->
# **函数模板**

---

### **函数模板的定义与概念**
函数模板是一种创建通用函数的机制，它可以处理不同数据类型的数据，避免为每种数据类型编写重复的函数代码。通过函数模板，你可以定义一个函数的通用形式，让编译器在使用时根据实际的参数类型自动生成具体的函数实例。

---

### **函数模板的语法**
函数模板的基本语法如下：
```cpp
template <typename T1, typename T2, ...>
返回类型 函数名(参数列表) {
    // 函数体
}
```

---

### **解释**
- `template`：这是定义模板的关键字，表明接下来要定义一个模板。
- `<typename T1, typename T2, ...>`：这是模板参数列表，`typename` 是用于声明模板类型参数的关键字，也可以使用 `class` 替代，`T1`、`T2` 等是模板类型参数的名称，可以自定义。
- `返回类型`：函数的返回类型，可以使用模板类型参数。
- `函数名`：函数的名称。
- `参数列表`：函数的参数列表，可以使用模板类型参数。

---

### **例子**
下面是一个使用函数模板实现的通用求最大值函数的示例：
```cpp
// 定义函数模板
template <typename T>
T max(T a, T b) {
    return (a > b)? a : b;
}
```

---

### **代码解释**

1. **函数模板定义**：`template <typename T>` 声明了一个模板类型参数 `T`，`max` 函数接受两个 `T` 类型的参数，并返回较大的那个。
2. **实例化**：分别调用 `max` 函数处理整数和浮点数。编译器会根据传入的参数类型自动实例化出具体的函数，即 `max<int>` 和 `max<double>`
3. **输出结果**：程序会输出整数和浮点数的最大值。

这个例子展示了函数模板的强大之处，通过一个通用的函数模板，可以处理不同数据类型的数据，提高了代码的复用性。

---

### **模板类型参数**

+ 在 C++ 里，`template <typename T>` 和 `template <class T>` 作用基本相同，都用于声明模板类型参数
+ typename语义上更强调 T 是一个任意类型，包括内置类型（如 int、double等）和用户自定义类型。当模板中涉及到嵌套依赖类型时，必须使用 typename 来明确告诉编译器这是一个类型。
+ class是在 C++ 早期就引入用于模板类型参数声明的关键字。随着C++的发展，为了更清晰地表达类型，引入了typename关键字。 
+ 从代码可读性和遵循现代 C++ 标准的角度考虑，建议在声明模板类型参数时优先使用 typename。

---

### **函数模板的重载**
在 C++ 中，函数模板的重载是指可以定义多个同名的函数模板或者函数模板与普通函数同名，编译器会根据调用时提供的参数，从这些候选函数中选择最合适的函数来调用。

---

### **函数模板的重载形式**
+ 普通函数与函数模板重载
可以定义一个普通函数和一个同名的函数模板。
+ 多个函数模板重载
也可以定义多个同名但模板参数列表不同的函数模板。

---

### **匹配调用次序**

当调用一个重载的函数时，C++ 编译器会按照以下次序来选择最合适的函数：
1. **普通函数优先**：如果存在一个普通函数，其参数类型与调用时提供的参数类型完全匹配，那么编译器会优先调用这个普通函数，而不会考虑函数模板。
2. **精确匹配的函数模板**：如果没有完全匹配的普通函数，编译器会尝试寻找精确匹配的函数模板。精确匹配意味着不需要进行类型转换，参数类型与模板实例化后的类型完全一致。
   
---

### **匹配调用次序**

3. **经过类型转换后匹配的普通函数**：如果没有精确匹配的函数模板，编译器会尝试对普通函数参数进行类型转换，然后寻找能够匹配的普通函数。
4. **如果都不匹配则报错**：如果经过上述步骤都没有找到合适的函数，编译器会报错。
 